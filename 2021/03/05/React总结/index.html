<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="React相比原生的好处 组件化这其中以react贯彻最为彻底，甚至可以到函数级别的原子组件，高度的组件化可以让我们的组件易于维护、易于组合扩展。 天然分层JQuery时代的代码大部分情况下是面条代码，耦合严重，现代框架不管是MVC、MVP或者是MVVM模式都可以帮助我们进行分层，代码解耦更易于读写操作。 生态现在主流框架都自带生态，不管是数据流管理架构还是UI库都有成熟的解决方案。 开发效率现代">
<meta property="og:type" content="article">
<meta property="og:title" content="React总结">
<meta property="og:url" content="http://example.com/2021/03/05/React%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="屠林涛X">
<meta property="og:description" content="React相比原生的好处 组件化这其中以react贯彻最为彻底，甚至可以到函数级别的原子组件，高度的组件化可以让我们的组件易于维护、易于组合扩展。 天然分层JQuery时代的代码大部分情况下是面条代码，耦合严重，现代框架不管是MVC、MVP或者是MVVM模式都可以帮助我们进行分层，代码解耦更易于读写操作。 生态现在主流框架都自带生态，不管是数据流管理架构还是UI库都有成熟的解决方案。 开发效率现代">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0f987b87c348189c0f4f528831955f~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c584f625bc04095b30138b41386074c~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4a7a0c1c7e24cf98be2fe0c678fdb0e~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b32fd31a5c410c9753ffb68d25251a~tplv-k3u1fbpfcp-watermark.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd1a8a58f88342a68cc88b91f33aad3b~tplv-k3u1fbpfcp-watermark.image">
<meta property="article:published_time" content="2021-03-05T10:53:41.000Z">
<meta property="article:modified_time" content="2021-03-05T11:05:51.497Z">
<meta property="article:author" content="屠林涛">
<meta property="article:tag" content="frontend">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0f987b87c348189c0f4f528831955f~tplv-k3u1fbpfcp-watermark.image">

<link rel="canonical" href="http://example.com/2021/03/05/React%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>React总结 | 屠林涛X</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="屠林涛X" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">屠林涛X</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/03/05/React%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="屠林涛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="屠林涛X">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-03-05 18:53:41 / 修改时间：19:05:51" itemprop="dateCreated datePublished" datetime="2021-03-05T18:53:41+08:00">2021-03-05</time>
            </span>

          
            <span id="/2021/03/05/React%E6%80%BB%E7%BB%93/" class="post-meta-item leancloud_visitors" data-flag-title="React总结" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/03/05/React%E6%80%BB%E7%BB%93/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/03/05/React%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="React相比原生的好处"><a href="#React相比原生的好处" class="headerlink" title="React相比原生的好处"></a>React相比原生的好处</h2><ul>
<li><strong>组件化</strong>这其中以react贯彻最为彻底，甚至可以到函数级别的原子组件，高度的组件化可以让我们的组件易于维护、易于组合扩展。</li>
<li><strong>天然分层</strong>JQuery时代的代码大部分情况下是面条代码，耦合严重，现代框架不管是MVC、MVP或者是MVVM模式都可以帮助我们进行分层，代码解耦更易于读写操作。</li>
<li><strong>生态</strong>现在主流框架都自带生态，不管是数据流管理架构还是UI库都有成熟的解决方案。</li>
<li><strong>开发效率</strong>现代前端框架都默认自动更新DOM，而不在是需要我们手动进行操作，解放了开发者的手动DOM成本，间接提高了开发效率，从根本上解决了UI与状态同步的问题。</li>
</ul>
<h2 id="React和Vue的对比"><a href="#React和Vue的对比" class="headerlink" title="React和Vue的对比"></a>React和Vue的对比</h2><ul>
<li><p><strong>相同</strong></p>
<ol>
<li>虚拟DOM – 映射真实DOM，通过新旧DOM的diff对比，更好的跟踪渲染页面。</li>
<li>组件化 – 将应用拆分成一个个功能明确的模块，每个模块之间可以通过合适的方式互相联系。</li>
<li>构建工具 – 都有自己的构建工具，通过webpack + babel去搭脚手架工具。</li>
<li>Chrome开发工具 – 两者都有很好的Chrome扩展去帮助查找Bug</li>
<li>配套框架 – Vue有Vue-router和Vuex，React有React-router和React-Redux</li>
</ol>
</li>
<li><p><strong>不同</strong></p>
<ol>
<li>模块 VS JSX – Vue推荐编写近似常规HTML的模板进行渲染，而React推荐JSX的书写方式。</li>
<li>监听数据变化的不同 – Vue使用的是可变数据，而React更强调数据的不可变。在Vue中通过v-model绑定的数据，用户改变输入值后对应的值也会做出相应的改变。而React则是需要通过setState进行设置的变化</li>
<li>Diff不同 – Vue通过双向链表实现边对比边更新DOM，而React通过Diff队列保存需要更新的DOM，得到patch树，在统一批量更新DOM</li>
<li>开发团队 – Vue开始的核心是Evan You，后面再招了其他人组成团队；React则是一开始就是Facebook团队搞的。所以网上对比源码情况的话，Vue的比React的简单易懂。</li>
</ol>
</li>
</ul>
<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><ul>
<li>调用setState之后发生了什么？<ul>
<li>在代码中调用setState之后，React会将传入的参数对象与组件当前的状态合并，触发所谓的调和过程</li>
<li>经过调和过程，React会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个UI界面</li>
<li>在React得到元素树之后，React会自动计算新树和老树之间的节点差异，然后根据差异对界面进行最小化重新渲染<br>在差异计算算法（Diff）中，React能够相对精准的知道哪些位置发生了改变，以及应该如何改变，保证了按需更新而不是全部重新渲染</li>
</ul>
</li>
</ul>
<ol>
<li>合并参数对象，触发调和过程</li>
<li>计算新树和老树差异（Diff）</li>
<li>根据差异进行最小化重新渲染</li>
</ol>
<h3 id="setState是同步"><a href="#setState是同步" class="headerlink" title="setState是同步"></a>setState是同步</h3><ul>
<li>有时候同步，有时候异步<ol>
<li>setState在合成事件和钩子函数中是异步的，在原生事件和setTimeout是异步的。</li>
<li>setState的异步，并不是说内部由异步代码实现，它本身执行的过程和代码是同步的，只是合成事件和钩子函数和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，从而形成了所谓的异步，</li>
<li>setState可以通过第二个参数，在回调方法中拿到更新后的结果</li>
</ol>
</li>
</ul>
<h2 id="React-this问题"><a href="#React-this问题" class="headerlink" title="React this问题"></a>React this问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2020&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;jsliang 2021&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">// 四种绑定方法</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">&#x27;App&#x27;</span>&gt;</span><br><span class="line">        &#123;<span class="comment">/* 方法一：通过 constructor 中进行 bind 绑定 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;btn <span class="number">1</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法二：在里边绑定 this */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;btn <span class="number">2</span>&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">        &#123;<span class="comment">/* 方法三：通过箭头函数返回事件 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="built_in">this</span>.handleClick()&#125;&gt;btn <span class="number">3</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 方法四：让方法变成箭头函数 */</span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick2&#125;&gt;btn <span class="number">4</span>&lt;/button&gt;</span><br><span class="line">        </span><br><span class="line">        &#123;<span class="comment">/* 额外：直接调用不需要绑定 this */</span>&#125;</span><br><span class="line">        &#123;<span class="built_in">this</span>.handleClick()&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用bind和箭头函数有什么区别<ul>
<li>箭头函数除了代码少，与普通函数最大的不同就是：this是由声明该函数时候定义的，一般是隐性定义为声明该函数时的作用域this。</li>
<li>通过bind的话，相当于：Foo.prototype.a = function() {}，是通过原型链的一个指针绑定的</li>
</ul>
</li>
</ul>
<h2 id="Redux的工作流程"><a href="#Redux的工作流程" class="headerlink" title="Redux的工作流程"></a>Redux的工作流程</h2><ul>
<li>redux的核心概念：<ul>
<li>Store：保存数据的地方，可以把它当成一个容器，整个应用只能有一个Store</li>
<li>State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合就叫State</li>
<li>Action：State的变化，会导致View的变化。但是，用户接触不到Stae，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。</li>
<li>Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action</li>
<li>Reducer：Store收到Action之后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。</li>
<li>dispatch：是View发出Action的唯一方法</li>
</ul>
</li>
<li>完成的工作流程<ol>
<li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</li>
<li>Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li>
<li>State一旦有变化，Store就会调用监听函数，来更新View<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d0f987b87c348189c0f4f528831955f~tplv-k3u1fbpfcp-watermark.image"></li>
</ol>
</li>
</ul>
<h2 id="react-redux是如何工作的？"><a href="#react-redux是如何工作的？" class="headerlink" title="react-redux是如何工作的？"></a>react-redux是如何工作的？</h2><ul>
<li>Provider：Provider的作用是从最外部封装了整个应用，并向connect模块传递store</li>
<li>connect：负责连接React和Redux<ul>
<li>获取state：connect通过context获取Provider中的store，通过store.getState()获取整个store tree上所有state</li>
<li>包装原组件：将state和action通过props的方式传入到原组件内部wrapWithConnect返回一个ReactComponent对象Connect， Connect重新render外部传入的原组件WrappedComponent，并把Connect中传入的mapStateToProps,mapDispatchToProps与组件上原有的props合并后，通过属性的方式传给WrappedComponent</li>
<li>监听store tree变化：connect缓存了store tree中state的状态，通过当前的state状态和变更前state状态进行比较，从而确定是否调用this.setState()方法触发Connect及其子组件的重新渲染<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c584f625bc04095b30138b41386074c~tplv-k3u1fbpfcp-watermark.image"></li>
</ul>
</li>
</ul>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><h3 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h3><ul>
<li>创建DOM树。用HTML解析器分析HTML元素，创建一棵DOM树</li>
<li>创建CSS规则书（CSS rule tree）。用CSS解析器解析CSS文件和inline样式，生成页面的样式表</li>
<li>创建Render树。将DOM树和CSS规则树关联起来，构建Render树</li>
<li>布局Layout。根据Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示器上出现的精确坐标</li>
<li>绘制Painting。在Render树和节点显示坐标的基础上，调用每个节点的paint方法，将它们绘制出来</li>
</ul>
<h3 id="DOM操作昂贵"><a href="#DOM操作昂贵" class="headerlink" title="DOM操作昂贵"></a>DOM操作昂贵</h3><p>由于在浏览器中操作DOM是很昂贵的</p>
<ul>
<li>用原生JS或者JQuery操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程<blockquote>
<p>拓展要点：回流和重绘</p>
</blockquote>
</li>
</ul>
<p>频繁地操作DOM，会产生一定的性能问题，因此我们需要在这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，这样保证了DOM不会出现性能很差的情况。</p>
<p>但是这样并不能解决问题，所以就有了虚拟DOM；</p>
<p>虚拟DOM本质就是用一个原生的JavaScript对象去描述一个DOM节点，是对真实DOM的一层抽象</p>
<blockquote>
<p>真实DOM节点</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>JS模拟虚拟DOM</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;container&#x27;</span> &#125;, &#123;</span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;新节点值&#x27;</span>])</span><br><span class="line">  ]),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> root = tree.render();</span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#container&#x27;</span>).appendChild(root);</span><br></pre></td></tr></table></figure>
<p>可以看到虚拟DOM对象最基本的三个属性</p>
<ul>
<li>标签类型</li>
<li>标签元素的属性</li>
<li>标签元素的子节点</li>
</ul>
<h3 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h3><p>两棵树完全对比的时间复杂度是0(n^3)，而React的Diff算法的时间复杂度是0(n)</p>
<p>要实现这么低的时间复杂度，意味着在比较差异时只会对同一层级的节点进行比较，因为如果进行完全的比较，算法实际复杂度会过高，所以舍弃了这种完全的比较方式，采用了同层比较的方式</p>
<p>Diff算法的核心就是对虚拟DOM节点进行深度优先遍历，并对每一个虚拟节点进行编号，在遍历的过程中对同一个层级的节点进行比较，最终得到比较后的差异</p>
<p>Diff的实现，最粗暴的方法就是遍历每个新虚拟DOM节点，和旧虚拟DOM节点比对。在旧DOM中是否存在，不同就卸载原来的改成新的</p>
<blockquote>
<p>React或Vue中的key：我们在写业务的时候，经常被告知key值不能是索引值index，why？？？</p>
</blockquote>
<p>假如有四个元素，旧的是1、2、3、4，新的元素是1、3、2、4，这个时候我们如果用了索引值index，那么它们始终只会是0-3。这样的话React或Vue就没法比较好的监听它的一个变动</p>
<p>所以一般来说，我们将key值定位成数组的id或者其他的值，方便它变动的时候去更好的监听它</p>
<p>这样子通过Diff比较完毕之后，我们就可以获取需要变动的内容，最终去更新真实的DOM节点</p>
<h3 id="虚拟DOM实现原理"><a href="#虚拟DOM实现原理" class="headerlink" title="虚拟DOM实现原理"></a>虚拟DOM实现原理</h3><ul>
<li>虚拟DOM本质上是JavaScript对象，是对真实DOM的抽象</li>
<li>状态变更的时候，记录新树和旧树的差异</li>
<li>最后把差异更新到真正的DOM中</li>
</ul>
<h3 id="虚拟DOM和真实DOM比对"><a href="#虚拟DOM和真实DOM比对" class="headerlink" title="虚拟DOM和真实DOM比对"></a>虚拟DOM和真实DOM比对</h3><ul>
<li>优点<ul>
<li>保证性能下限： 虚拟DOM可以经过Diff找出最小差异，然后批量进行patch，这种操作虽然比不上手动优化，但是比起粗暴的DOM操作性能要好很多，因此虚拟DOM可以保证性能下限</li>
<li>无需手动操作DOM：虚拟DOM的Diff和patch都是在一次更新中自动进行的，我们无需手动操作DOM，极大提高了开发效率</li>
<li>跨平台：虚拟DOM本质上是JavaScript对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便地跨平台操作，例如服务器渲染、移动端开发等</li>
</ul>
</li>
<li>缺点<ul>
<li>无法进行极致优化：在一些性能要求极高的应用中虚拟DOM无法进行针对性的细致优化，例如vsCode采用直接手动操作DOM的方式进行极端的性能优化。</li>
</ul>
</li>
</ul>
<h2 id="Diff算法-1"><a href="#Diff算法-1" class="headerlink" title="Diff算法"></a>Diff算法</h2><p>比较原生虚拟DOM和新的虚拟DOM的区别，使用Diff(Different)算法<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4a7a0c1c7e24cf98be2fe0c678fdb0e~tplv-k3u1fbpfcp-watermark.image"></p>
<p>如上图，在React中，对于setState，它采用异步操作，统一对state中的数据进行更改</p>
<hr>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91b32fd31a5c410c9753ffb68d25251a~tplv-k3u1fbpfcp-watermark.image"></p>
<ol>
<li>比对第一层的DOM节点，如果它相同，则往下继续对比；如果它不同，则停止对比，更新第一层及以下的DOM节点</li>
<li>比对第二次的DOM节点……</li>
<li>形成一种比对算法</li>
</ol>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd1a8a58f88342a68cc88b91f33aad3b~tplv-k3u1fbpfcp-watermark.image"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>把树形结构按照层级分解，只比较同级元素</li>
<li>给列表结构的每个单元添加唯一的key属性，方便比较</li>
<li>React只会匹配相同class的component(这里面的class指的是组件的名字)</li>
<li>合并操作，调用component的setState方法的时候，React将其标记为dirty。到每一个事件循环结束，React检查所有标记dirty的component重新绘制</li>
<li>选择性子树渲染。开发人员可以重写shouldComponentUpdate提高Diff的性能</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/frontend/" rel="tag"># frontend</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2021/03/05/HTTP-HTTPS/" rel="next" title="HTTP/HTTPS">
      HTTP/HTTPS <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">1.</span> <span class="nav-text">React相比原生的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React%E5%92%8CVue%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.</span> <span class="nav-text">React和Vue的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setState"><span class="nav-number">3.</span> <span class="nav-text">setState</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#setState%E6%98%AF%E5%90%8C%E6%AD%A5"><span class="nav-number">3.1.</span> <span class="nav-text">setState是同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-this%E9%97%AE%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">React this问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redux%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">Redux的工作流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#react-redux%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">react-redux是如何工作的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM"><span class="nav-number">7.</span> <span class="nav-text">虚拟DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">浏览器渲染过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E6%93%8D%E4%BD%9C%E6%98%82%E8%B4%B5"><span class="nav-number">7.2.</span> <span class="nav-text">DOM操作昂贵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diff%E7%AE%97%E6%B3%95"><span class="nav-number">7.3.</span> <span class="nav-text">Diff算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.</span> <span class="nav-text">虚拟DOM实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E7%9C%9F%E5%AE%9EDOM%E6%AF%94%E5%AF%B9"><span class="nav-number">7.5.</span> <span class="nav-text">虚拟DOM和真实DOM比对</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Diff%E7%AE%97%E6%B3%95-1"><span class="nav-number">8.</span> <span class="nav-text">Diff算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.0.1.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">屠林涛</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">屠林涛</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : true,
      appId      : 'kUoAIWDCpShnxEVA6ajiUaeb-gzGzoHsz',
      appKey     : 'A20OGWJ6gcoCnIyTmWvzbHGh',
      placeholder: "go go go ～～～",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

    </div>
</body>
</html>
